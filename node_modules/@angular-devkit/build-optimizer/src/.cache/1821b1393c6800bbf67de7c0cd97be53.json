{"remainingRequest":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/ng-sidebar/lib/sidebar.component.js","dependencies":[{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/ng-sidebar/lib/sidebar.component.js","mtime":1497055971000},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/cache-loader/dist/cjs.js","mtime":1549951013815},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar common_1 = require(\"@angular/common\");\nvar sidebar_container_component_1 = require(\"./sidebar-container.component\");\nvar sidebar_service_1 = require(\"./sidebar.service\");\nvar utils_1 = require(\"./utils\");\nvar Sidebar = /*@__PURE__*/ (function () {\n    function Sidebar(_container, _ref, _sidebarService, platformId) {\n        this._container = _container;\n        this._ref = _ref;\n        this._sidebarService = _sidebarService;\n        // `openedChange` allows for \"2-way\" data binding\n        this.opened = false;\n        this.openedChange = new core_1.EventEmitter();\n        this.mode = 'over';\n        this.dock = false;\n        this.dockedSize = '0px';\n        this.position = 'start';\n        this.animate = true;\n        this.trapFocus = false;\n        this.autoFocus = true;\n        this.showBackdrop = false;\n        this.closeOnClickBackdrop = false;\n        this.closeOnClickOutside = false;\n        this.keyClose = false;\n        this.keyCode = 27; // Default to ESC key\n        this.onOpenStart = new core_1.EventEmitter();\n        this.onOpened = new core_1.EventEmitter();\n        this.onCloseStart = new core_1.EventEmitter();\n        this.onClosed = new core_1.EventEmitter();\n        this.onModeChange = new core_1.EventEmitter();\n        this.onPositionChange = new core_1.EventEmitter();\n        /** @internal */\n        this._onRerender = new core_1.EventEmitter();\n        this._focusableElementsString = 'a[href], area[href], input:not([disabled]), select:not([disabled]),' +\n            'textarea:not([disabled]), button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';\n        this._clickEvent = 'click';\n        this._onClickOutsideAttached = false;\n        this._onKeyDownAttached = false;\n        this._onResizeAttached = false;\n        this._isBrowser = common_1.isPlatformBrowser(platformId);\n        if (!this._container) {\n            throw new Error('<ng-sidebar> must be inside a <ng-sidebar-container>');\n        }\n        if (this._isBrowser && utils_1.isIOS() && 'ontouchstart' in window) {\n            this._clickEvent = 'touchstart';\n        }\n        this._normalizePosition();\n        this.open = this.open.bind(this);\n        this.close = this.close.bind(this);\n        this._onTransitionEnd = this._onTransitionEnd.bind(this);\n        this._onFocusTrap = this._onFocusTrap.bind(this);\n        this._onClickOutside = this._onClickOutside.bind(this);\n        this._onKeyDown = this._onKeyDown.bind(this);\n        this._onResize = this._onResize.bind(this);\n        this._openSub = this._sidebarService.onOpen(this.open);\n        this._closeSub = this._sidebarService.onClose(this.close);\n    }\n    Sidebar.prototype.ngOnInit = function () {\n        var _this = this;\n        if (!this._isBrowser) {\n            return;\n        }\n        this._container._addSidebar(this);\n        // Prevents an initial transition hiccup in IE (issue #59)\n        if (this.animate) {\n            this.animate = false;\n            setTimeout(function () {\n                _this.animate = true;\n            });\n        }\n    };\n    Sidebar.prototype.ngOnChanges = function (changes) {\n        var _this = this;\n        if (!this._isBrowser) {\n            return;\n        }\n        if (changes['opened']) {\n            if (changes['opened'].currentValue) {\n                this.open();\n            }\n            else {\n                this.close();\n            }\n        }\n        if (changes['closeOnClickOutside'] || changes['keyClose']) {\n            this._initCloseListeners();\n        }\n        if (changes['position']) {\n            // Handle \"start\" and \"end\" aliases\n            this._normalizePosition();\n            // Emit change in timeout to allow for position change to be rendered first\n            setTimeout(function () {\n                _this.onPositionChange.emit(changes['position'].currentValue);\n            });\n        }\n        if (changes['mode']) {\n            setTimeout(function () {\n                _this.onModeChange.emit(changes['mode'].currentValue);\n            });\n        }\n        if (changes['dock']) {\n            this.triggerRerender();\n        }\n        if (changes['autoCollapseHeight'] || changes['autoCollapseWidth']) {\n            this._initCollapseListeners();\n        }\n    };\n    Sidebar.prototype.ngOnDestroy = function () {\n        if (!this._isBrowser) {\n            return;\n        }\n        this._destroyCloseListeners();\n        this._destroyCollapseListeners();\n        if (this._openSub) {\n            this._openSub.unsubscribe();\n        }\n        if (this._closeSub) {\n            this._closeSub.unsubscribe();\n        }\n        this._container._removeSidebar(this);\n    };\n    // Sidebar toggling\n    // ==============================================================================================\n    /**\n     * Opens the sidebar and emits the appropriate events.\n     */\n    Sidebar.prototype.open = function () {\n        var _this = this;\n        if (!this._isBrowser) {\n            return;\n        }\n        this.opened = true;\n        this.openedChange.emit(true);\n        this.onOpenStart.emit();\n        this._ref.detectChanges();\n        setTimeout(function () {\n            if (_this.animate && !_this._isModeSlide) {\n                _this._elSidebar.nativeElement.addEventListener('transitionend', _this._onTransitionEnd);\n            }\n            else {\n                _this._setFocused();\n                _this._initCloseListeners();\n                if (_this.opened) {\n                    _this.onOpened.emit();\n                }\n            }\n        });\n    };\n    /**\n     * Closes the sidebar and emits the appropriate events.\n     */\n    Sidebar.prototype.close = function () {\n        var _this = this;\n        if (!this._isBrowser) {\n            return;\n        }\n        this.opened = false;\n        this.openedChange.emit(false);\n        this.onCloseStart.emit();\n        this._ref.detectChanges();\n        setTimeout(function () {\n            if (_this.animate && !_this._isModeSlide) {\n                _this._elSidebar.nativeElement.addEventListener('transitionend', _this._onTransitionEnd);\n            }\n            else {\n                _this._setFocused();\n                _this._destroyCloseListeners();\n                if (!_this.opened) {\n                    _this.onClosed.emit();\n                }\n            }\n        });\n    };\n    /**\n     * Manually trigger a re-render of the container. Useful if the sidebar contents might change.\n     */\n    Sidebar.prototype.triggerRerender = function () {\n        var _this = this;\n        if (!this._isBrowser) {\n            return;\n        }\n        setTimeout(function () {\n            _this._onRerender.emit();\n        });\n    };\n    /**\n     * @internal\n     *\n     * Computes the transform styles for the sidebar template.\n     *\n     * @return {CSSStyleDeclaration} The transform styles, with the WebKit-prefixed version as well.\n     */\n    Sidebar.prototype._getStyle = function () {\n        var transformStyle = null;\n        var marginStyle = {};\n        // Hides sidebar off screen\n        if (!this.opened || this._isModeSlide) {\n            var isLeftOrTop = this.position === 'left' || this.position === 'top';\n            var isLeftOrRight = this.position === 'left' || this.position === 'right';\n            var transformDir = isLeftOrRight ? 'X' : 'Y';\n            var translateAmt = (isLeftOrTop ? '-' : '') + \"100%\";\n            transformStyle = \"translate\" + transformDir + \"(\" + translateAmt + \")\";\n            // Docked mode: partially remains open\n            if (this.dock && this._dockedSize > 0 && !(this._isModeSlide && this.opened)) {\n                var marginPos = \"margin\" + utils_1.upperCaseFirst(this.position);\n                marginStyle[marginPos] = this.dockedSize;\n            }\n        }\n        return Object.assign(marginStyle, {\n            webkitTransform: transformStyle,\n            transform: transformStyle\n        });\n    };\n    /**\n     * @internal\n     *\n     * Handles the `transitionend` event on the sidebar to emit the onOpened/onClosed events after the transform\n     * transition is completed.\n     */\n    Sidebar.prototype._onTransitionEnd = function (e) {\n        if (e.target === this._elSidebar.nativeElement && e.propertyName.endsWith('transform')) {\n            this._setFocused();\n            if (this.opened) {\n                this._initCloseListeners();\n                this.onOpened.emit();\n            }\n            else {\n                this._destroyCloseListeners();\n                this.onClosed.emit();\n            }\n            this._elSidebar.nativeElement.removeEventListener('transitionend', this._onTransitionEnd);\n        }\n    };\n    Object.defineProperty(Sidebar.prototype, \"_shouldTrapFocus\", {\n        // Focus on open/close\n        // ==============================================================================================\n        /**\n         * Returns whether focus should be trapped within the sidebar.\n         *\n         * @return {boolean} Trap focus inside sidebar.\n         */\n        get: function () {\n            return this.opened && this.trapFocus && this._isModeOver;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Sets focus to the first focusable element inside the sidebar.\n     */\n    Sidebar.prototype._focusFirstItem = function () {\n        if (this._focusableElements && this._focusableElements.length > 0) {\n            this._focusableElements[0].focus();\n        }\n    };\n    /**\n     * Loops focus back to the start of the sidebar if set to do so.\n     */\n    Sidebar.prototype._onFocusTrap = function (e) {\n        if (this._shouldTrapFocus && !this._elSidebar.nativeElement.contains(e.target)) {\n            this._focusFirstItem();\n        }\n    };\n    /**\n     * Handles the ability to focus sidebar elements when it's open/closed to ensure that the sidebar is inert when\n     * appropriate.\n     */\n    Sidebar.prototype._setFocused = function () {\n        this._focusableElements = Array.from(this._elSidebar.nativeElement.querySelectorAll(this._focusableElementsString));\n        if (this.opened) {\n            this._focusedBeforeOpen = document.activeElement;\n            // Restore focusability, with previous tabindex attributes\n            for (var _i = 0, _a = this._focusableElements; _i < _a.length; _i++) {\n                var el = _a[_i];\n                var prevTabIndex = el.getAttribute('__tabindex__');\n                if (prevTabIndex !== null) {\n                    el.setAttribute('tabindex', prevTabIndex);\n                    el.removeAttribute('__tabindex__');\n                }\n                else {\n                    el.removeAttribute('tabindex');\n                }\n            }\n            if (this.autoFocus) {\n                this._focusFirstItem();\n            }\n            document.addEventListener('focus', this._onFocusTrap, true);\n        }\n        else {\n            // Manually make all focusable elements unfocusable, saving existing tabindex attributes\n            for (var _b = 0, _c = this._focusableElements; _b < _c.length; _b++) {\n                var el = _c[_b];\n                var existingTabIndex = el.getAttribute('tabindex');\n                el.setAttribute('tabindex', '-1');\n                if (existingTabIndex !== null) {\n                    el.setAttribute('__tabindex__', existingTabIndex);\n                }\n            }\n            document.removeEventListener('focus', this._onFocusTrap, true);\n            // Set focus back to element before the sidebar was opened\n            if (this._focusedBeforeOpen && this.autoFocus && this._isModeOver) {\n                this._focusedBeforeOpen.focus();\n                this._focusedBeforeOpen = null;\n            }\n        }\n    };\n    // Close event handlers\n    // ==============================================================================================\n    /**\n     * Initializes event handlers for the closeOnClickOutside and keyClose options.\n     */\n    Sidebar.prototype._initCloseListeners = function () {\n        var _this = this;\n        if (this.opened && (this.closeOnClickOutside || this.keyClose)) {\n            // In a timeout so that things render first\n            setTimeout(function () {\n                if (_this.closeOnClickOutside && !_this._onClickOutsideAttached) {\n                    document.addEventListener(_this._clickEvent, _this._onClickOutside);\n                    _this._onClickOutsideAttached = true;\n                }\n                if (_this.keyClose && !_this._onKeyDownAttached) {\n                    document.addEventListener('keydown', _this._onKeyDown);\n                    _this._onKeyDownAttached = true;\n                }\n            });\n        }\n    };\n    /**\n     * Destroys the event handlers from _initCloseListeners.\n     */\n    Sidebar.prototype._destroyCloseListeners = function () {\n        if (this._onClickOutsideAttached) {\n            document.removeEventListener(this._clickEvent, this._onClickOutside);\n            this._onClickOutsideAttached = false;\n        }\n        if (this._onKeyDownAttached) {\n            document.removeEventListener('keydown', this._onKeyDown);\n            this._onKeyDownAttached = false;\n        }\n    };\n    /**\n     * Handles `click` events on anything while the sidebar is open for the closeOnClickOutside option.\n     * Programatically closes the sidebar if a click occurs outside the sidebar.\n     *\n     * @param e {MouseEvent} Mouse click event.\n     */\n    Sidebar.prototype._onClickOutside = function (e) {\n        if (this._onClickOutsideAttached && this._elSidebar && !this._elSidebar.nativeElement.contains(e.target)) {\n            this.close();\n        }\n    };\n    /**\n     * Handles the `keydown` event for the keyClose option.\n     *\n     * @param e {KeyboardEvent} Normalized keydown event.\n     */\n    Sidebar.prototype._onKeyDown = function (e) {\n        e = e || window.event;\n        if (e.keyCode === this.keyCode) {\n            this.close();\n        }\n    };\n    // Auto collapse handlers\n    // ==============================================================================================\n    Sidebar.prototype._initCollapseListeners = function () {\n        var _this = this;\n        if (this.autoCollapseHeight || this.autoCollapseWidth) {\n            // In a timeout so that things render first\n            setTimeout(function () {\n                if (!_this._onResizeAttached) {\n                    window.addEventListener('resize', _this._onResize);\n                    _this._onResizeAttached = true;\n                }\n            });\n        }\n    };\n    Sidebar.prototype._destroyCollapseListeners = function () {\n        if (this._onResizeAttached) {\n            window.removeEventListener('resize', this._onResize);\n            this._onResizeAttached = false;\n        }\n    };\n    Sidebar.prototype._onResize = function () {\n        var winHeight = window.innerHeight;\n        var winWidth = window.innerWidth;\n        if (this.autoCollapseHeight) {\n            if (winHeight <= this.autoCollapseHeight && this.opened) {\n                this._wasCollapsed = true;\n                this.close();\n            }\n            else if (winHeight > this.autoCollapseHeight && this._wasCollapsed) {\n                this.open();\n                this._wasCollapsed = false;\n            }\n        }\n        if (this.autoCollapseWidth) {\n            if (winWidth <= this.autoCollapseWidth && this.opened) {\n                this._wasCollapsed = true;\n                this.close();\n            }\n            else if (winWidth > this.autoCollapseWidth && this._wasCollapsed) {\n                this.open();\n                this._wasCollapsed = false;\n            }\n        }\n    };\n    Object.defineProperty(Sidebar.prototype, \"_height\", {\n        // Helpers\n        // ==============================================================================================\n        /**\n         * @internal\n         *\n         * Returns the rendered height of the sidebar (or the docked size).\n         * This is used in the sidebar container.\n         *\n         * @return {number} Height of sidebar.\n         */\n        get: function () {\n            if (this._elSidebar.nativeElement) {\n                return this._isDocked ?\n                    this._dockedSize :\n                    this._elSidebar.nativeElement.offsetHeight;\n            }\n            return 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_width\", {\n        /**\n         * @internal\n         *\n         * Returns the rendered width of the sidebar (or the docked size).\n         * This is used in the sidebar container.\n         *\n         * @return {number} Width of sidebar.\n         */\n        get: function () {\n            if (this._elSidebar.nativeElement) {\n                return this._isDocked ?\n                    this._dockedSize :\n                    this._elSidebar.nativeElement.offsetWidth;\n            }\n            return 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_dockedSize\", {\n        /**\n         * @internal\n         *\n         * Returns the docked size as a number.\n         *\n         * @return {number} Docked size.\n         */\n        get: function () {\n            return parseFloat(this.dockedSize);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_isModeOver\", {\n        /**\n         * @internal\n         *\n         * Returns whether the sidebar is over mode.\n         *\n         * @return {boolean} Sidebar's mode is \"over\".\n         */\n        get: function () {\n            return this.mode === 'over';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_isModePush\", {\n        /**\n         * @internal\n         *\n         * Returns whether the sidebar is push mode.\n         *\n         * @return {boolean} Sidebar's mode is \"push\".\n         */\n        get: function () {\n            return this.mode === 'push';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_isModeSlide\", {\n        /**\n         * @internal\n         *\n         * Returns whether the sidebar is slide mode.\n         *\n         * @return {boolean} Sidebar's mode is \"slide\".\n         */\n        get: function () {\n            return this.mode === 'slide';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_isDocked\", {\n        /**\n         * @internal\n         *\n         * Returns whether the sidebar is \"docked\" -- i.e. it is closed but in dock mode.\n         *\n         * @return {boolean} Sidebar is docked.\n         */\n        get: function () {\n            return this.dock && this.dockedSize && !this.opened;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(Sidebar.prototype, \"_isInert\", {\n        /**\n         * @internal\n         *\n         * Returns whether the sidebar is inert -- i.e. the contents cannot be focused.\n         *\n         * @return {boolean} Sidebar is inert.\n         */\n        get: function () {\n            return !this.opened && !this.dock;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \"Normalizes\" position. For example, \"start\" would be \"left\" if the page is LTR.\n     */\n    Sidebar.prototype._normalizePosition = function () {\n        var ltr = utils_1.isLTR();\n        if (this.position === 'start') {\n            this.position = ltr ? 'left' : 'right';\n        }\n        else if (this.position === 'end') {\n            this.position = ltr ? 'right' : 'left';\n        }\n    };\n    Sidebar.decorators = [\n        { type: core_1.Component, args: [{\n                    selector: 'ng-sidebar',\n                    template: \"\\n    <aside #sidebar\\n      role=\\\"complementary\\\"\\n      [attr.aria-hidden]=\\\"!opened\\\"\\n      [attr.aria-label]=\\\"ariaLabel\\\"\\n      class=\\\"ng-sidebar ng-sidebar--{{opened ? 'opened' : 'closed'}} ng-sidebar--{{position}} ng-sidebar--{{mode}}\\\"\\n      [class.ng-sidebar--docked]=\\\"_isDocked\\\"\\n      [class.ng-sidebar--inert]=\\\"_isInert\\\"\\n      [class.ng-sidebar--animate]=\\\"animate\\\"\\n      [ngClass]=\\\"sidebarClass\\\"\\n      [ngStyle]=\\\"_getStyle()\\\">\\n      <ng-content></ng-content>\\n    </aside>\\n  \",\n                    styles: [\"\\n    .ng-sidebar {\\n      background-color: #fff;\\n      overflow: auto;\\n      pointer-events: auto;\\n      position: fixed;\\n      touch-action: auto;\\n      will-change: initial;\\n      z-index: 99999999;\\n    }\\n\\n      .ng-sidebar--left {\\n        bottom: 0;\\n        left: 0;\\n        top: 0;\\n      }\\n\\n      .ng-sidebar--right {\\n        bottom: 0;\\n        right: 0;\\n        top: 0;\\n      }\\n\\n      .ng-sidebar--top {\\n        left: 0;\\n        right: 0;\\n        top: 0;\\n      }\\n\\n      .ng-sidebar--bottom {\\n        bottom: 0;\\n        left: 0;\\n        right: 0;\\n      }\\n\\n    .ng-sidebar--inert {\\n      pointer-events: none;\\n      touch-action: none;\\n      will-change: transform;\\n    }\\n\\n    .ng-sidebar--animate.ng-sidebar {\\n      -webkit-transition: -webkit-transform 0.3s cubic-bezier(0, 0, 0.3, 1);\\n      transition: transform 0.3s cubic-bezier(0, 0, 0.3, 1);\\n    }\\n  \"],\n                    changeDetection: core_1.ChangeDetectionStrategy.OnPush\n                },] },\n    ];\n    Sidebar.propDecorators = {\n        'opened': [{ type: core_1.Input },],\n        'openedChange': [{ type: core_1.Output },],\n        'mode': [{ type: core_1.Input },],\n        'dock': [{ type: core_1.Input },],\n        'dockedSize': [{ type: core_1.Input },],\n        'position': [{ type: core_1.Input },],\n        'animate': [{ type: core_1.Input },],\n        'autoCollapseHeight': [{ type: core_1.Input },],\n        'autoCollapseWidth': [{ type: core_1.Input },],\n        'sidebarClass': [{ type: core_1.Input },],\n        'ariaLabel': [{ type: core_1.Input },],\n        'trapFocus': [{ type: core_1.Input },],\n        'autoFocus': [{ type: core_1.Input },],\n        'showBackdrop': [{ type: core_1.Input },],\n        'closeOnClickBackdrop': [{ type: core_1.Input },],\n        'closeOnClickOutside': [{ type: core_1.Input },],\n        'keyClose': [{ type: core_1.Input },],\n        'keyCode': [{ type: core_1.Input },],\n        'onOpenStart': [{ type: core_1.Output },],\n        'onOpened': [{ type: core_1.Output },],\n        'onCloseStart': [{ type: core_1.Output },],\n        'onClosed': [{ type: core_1.Output },],\n        'onModeChange': [{ type: core_1.Output },],\n        'onPositionChange': [{ type: core_1.Output },],\n        '_onRerender': [{ type: core_1.Output },],\n        '_elSidebar': [{ type: core_1.ViewChild, args: ['sidebar',] },],\n    };\n    return Sidebar;\n}());\nexports.Sidebar = Sidebar;\n",null]}