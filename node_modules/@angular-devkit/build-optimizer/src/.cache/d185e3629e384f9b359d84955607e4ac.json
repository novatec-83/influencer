{"remainingRequest":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@swimlane/ngx-datatable/release/components/body/body.component.js","dependencies":[{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@swimlane/ngx-datatable/release/components/body/body.component.js","mtime":1499611568000},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/cache-loader/dist/cjs.js","mtime":1549951013815},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar utils_1 = require(\"../../utils\");\nvar scroller_component_1 = require(\"./scroller.component\");\nvar DataTableBodyComponent = /*@__PURE__*/ (function () {\n    /**\n     * Creates an instance of DataTableBodyComponent.\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    function DataTableBodyComponent() {\n        var _this = this;\n        this.selected = [];\n        this.scroll = new core_1.EventEmitter();\n        this.page = new core_1.EventEmitter();\n        this.activate = new core_1.EventEmitter();\n        this.select = new core_1.EventEmitter();\n        this.detailToggle = new core_1.EventEmitter();\n        this.rowContextmenu = new core_1.EventEmitter(false);\n        this.rowHeightsCache = new utils_1.RowHeightCache();\n        this.temp = [];\n        this.offsetY = 0;\n        this.indexes = {};\n        /**\n         * Get the height of the detail row.\n         *\n         * @param {*} [row]\n         * @param {*} [index]\n         * @returns {number}\n         *\n         * @memberOf DataTableBodyComponent\n         */\n        this.getDetailRowHeight = function (row, index) {\n            if (!_this.rowDetail)\n                return 0;\n            var rowHeight = _this.rowDetail.rowHeight;\n            return typeof rowHeight === 'function' ? rowHeight(row, index) : rowHeight;\n        };\n        // declare fn here so we can get access to the `this` property\n        this.rowTrackingFn = function (index, row) {\n            if (this.trackByProp) {\n                return row.$$index + \"-\" + this.trackByProp;\n            }\n            else {\n                return row.$$index;\n            }\n        }.bind(this);\n    }\n    Object.defineProperty(DataTableBodyComponent.prototype, \"pageSize\", {\n        get: function () {\n            return this._pageSize;\n        },\n        set: function (val) {\n            this._pageSize = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rows\", {\n        get: function () {\n            return this._rows;\n        },\n        set: function (val) {\n            this._rows = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"columns\", {\n        get: function () {\n            return this._columns;\n        },\n        set: function (val) {\n            this._columns = val;\n            var colsByPin = utils_1.columnsByPin(val);\n            this.columnGroupWidths = utils_1.columnGroupWidths(colsByPin, val);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"offset\", {\n        get: function () {\n            return this._offset;\n        },\n        set: function (val) {\n            this._offset = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"rowCount\", {\n        get: function () {\n            return this._rowCount;\n        },\n        set: function (val) {\n            this._rowCount = val;\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyWidth\", {\n        get: function () {\n            if (this.scrollbarH) {\n                return this.innerWidth + 'px';\n            }\n            else {\n                return '100%';\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"bodyHeight\", {\n        get: function () {\n            return this._bodyHeight;\n        },\n        set: function (val) {\n            if (this.scrollbarV) {\n                this._bodyHeight = val + 'px';\n            }\n            else {\n                this._bodyHeight = 'auto';\n            }\n            this.recalcLayout();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"selectEnabled\", {\n        /**\n         * Returns if selection is enabled.\n         *\n         * @readonly\n         * @type {boolean}\n         * @memberOf DataTableBodyComponent\n         */\n        get: function () {\n            return !!this.selectionType;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(DataTableBodyComponent.prototype, \"scrollHeight\", {\n        /**\n         * Property that would calculate the height of scroll bar\n         * based on the row heights cache for virtual scroll. Other scenarios\n         * calculate scroll height automatically (as height will be undefined).\n         *\n         * @readonly\n         * @type {number}\n         * @memberOf DataTableBodyComponent\n         */\n        get: function () {\n            if (this.scrollbarV) {\n                return this.rowHeightsCache.query(this.rowCount - 1);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Called after the constructor, initializing input properties\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.ngOnInit = function () {\n        var _this = this;\n        if (this.rowDetail) {\n            this.listener = this.rowDetail.toggle\n                .subscribe(function (_a) {\n                var type = _a.type, value = _a.value;\n                if (type === 'row')\n                    _this.toggleRowExpansion(value);\n                if (type === 'all')\n                    _this.toggleAllRows(value);\n            });\n        }\n    };\n    /**\n     * Called once, before the instance is destroyed.\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.ngOnDestroy = function () {\n        if (this.rowDetail)\n            this.listener.unsubscribe();\n    };\n    /**\n     * Updates the Y offset given a new offset.\n     *\n     * @param {number} [offset]\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.updateOffsetY = function (offset) {\n        // scroller is missing on empty table\n        if (!this.scroller)\n            return;\n        if (this.scrollbarV && offset) {\n            // First get the row Index that we need to move to.\n            var rowIndex = this.pageSize * offset;\n            offset = this.rowHeightsCache.query(rowIndex - 1);\n        }\n        this.scroller.setOffset(offset || 0);\n    };\n    /**\n     * Body was scrolled, this is mainly useful for\n     * when a user is server-side pagination via virtual scroll.\n     *\n     * @param {*} event\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.onBodyScroll = function (event) {\n        var scrollYPos = event.scrollYPos;\n        var scrollXPos = event.scrollXPos;\n        // if scroll change, trigger update\n        // this is mainly used for header cell positions\n        if (this.offsetY !== scrollYPos || this.offsetX !== scrollXPos) {\n            this.scroll.emit({\n                offsetY: scrollYPos,\n                offsetX: scrollXPos\n            });\n        }\n        this.offsetY = scrollYPos;\n        this.offsetX = scrollXPos;\n        this.updateIndexes();\n        this.updatePage(event.direction);\n        this.updateRows();\n    };\n    /**\n     * Updates the page given a direction.\n     *\n     * @param {string} direction\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.updatePage = function (direction) {\n        var offset = this.indexes.first / this.pageSize;\n        if (direction === 'up') {\n            offset = Math.ceil(offset);\n        }\n        else if (direction === 'down') {\n            offset = Math.ceil(offset);\n        }\n        if (direction !== undefined && !isNaN(offset)) {\n            this.page.emit({ offset: offset });\n        }\n    };\n    /**\n     * Updates the rows in the view port\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.updateRows = function () {\n        var _a = this.indexes, first = _a.first, last = _a.last;\n        var rowIndex = first;\n        var idx = 0;\n        var temp = [];\n        while (rowIndex < last && rowIndex < this.rowCount) {\n            var row = this.rows[rowIndex];\n            if (row) {\n                row.$$index = rowIndex;\n                temp[idx] = row;\n            }\n            idx++;\n            rowIndex++;\n        }\n        this.temp = temp;\n    };\n    /**\n     * Get the row height\n     *\n     * @param {*} row\n     * @returns {number}\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getRowHeight = function (row) {\n        var rowHeight = this.rowHeight;\n        // if its a function return it\n        if (typeof this.rowHeight === 'function') {\n            rowHeight = this.rowHeight(row);\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculate row height based on the expanded state of the row.\n     *\n     * @param {*} row the row for which the height need to be calculated.\n     * @returns {number} height of the row.\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getRowAndDetailHeight = function (row) {\n        var rowHeight = this.getRowHeight(row);\n        // Adding detail row height if its expanded.\n        if (row.$$expanded === 1) {\n            rowHeight += this.getDetailRowHeight(row);\n        }\n        return rowHeight;\n    };\n    /**\n     * Calculates the styles for the row so that the rows can be moved in 2D space\n     * during virtual scroll inside the DOM.   In the below case the Y position is\n     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is\n     * 100 px then following styles are generated:\n     *\n     * transform: translate3d(0px, 0px, 0px);    ->  row0\n     * transform: translate3d(0px, 30px, 0px);   ->  row1\n     * transform: translate3d(0px, 130px, 0px);  ->  row2\n     *\n     * Row heights have to be calculated based on the row heights cache as we wont\n     * be able to determine which row is of what height before hand.  In the above\n     * case the positionY of the translate3d for row2 would be the sum of all the\n     * heights of the rows before it (i.e. row0 and row1).\n     *\n     * @param {*} row The row that needs to be placed in the 2D space.\n     * @returns {*} Returns the CSS3 style to be applied\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getRowsStyles = function (row) {\n        var rowHeight = this.getRowAndDetailHeight(row);\n        var styles = {\n            height: rowHeight + 'px'\n        };\n        if (this.scrollbarV) {\n            var idx = row ? row.$$index : 0;\n            // const pos = idx * rowHeight;\n            // The position of this row would be the sum of all row heights\n            // until the previous row position.\n            var pos = this.rowHeightsCache.query(idx - 1);\n            utils_1.translateXY(styles, 0, pos);\n        }\n        return styles;\n    };\n    /**\n     * Hides the loading indicator\n     *\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.hideIndicator = function () {\n        var _this = this;\n        setTimeout(function () { return _this.loadingIndicator = false; }, 500);\n    };\n    /**\n     * Updates the index of the rows in the viewport\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.updateIndexes = function () {\n        var first = 0;\n        var last = 0;\n        if (this.scrollbarV) {\n            // Calculation of the first and last indexes will be based on where the\n            // scrollY position would be at.  The last index would be the one\n            // that shows up inside the view port the last.\n            var height = parseInt(this.bodyHeight, 0);\n            first = this.rowHeightsCache.getRowIndex(this.offsetY);\n            last = this.rowHeightsCache.getRowIndex(height + this.offsetY) + 1;\n        }\n        else {\n            // The server is handling paging and will pass an array that begins with the\n            // element at a specified offset.  first should always be 0 with external paging.\n            if (!this.externalPaging) {\n                first = Math.max(this.offset * this.pageSize, 0);\n            }\n            last = Math.min((first + this.pageSize), this.rowCount);\n        }\n        this.indexes = { first: first, last: last };\n    };\n    /**\n     * Refreshes the full Row Height cache.  Should be used\n     * when the entire row array state has changed.\n     *\n     * @returns {void}\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.refreshRowHeightCache = function () {\n        if (!this.scrollbarV)\n            return;\n        // clear the previous row height cache if already present.\n        // this is useful during sorts, filters where the state of the\n        // rows array is changed.\n        this.rowHeightsCache.clearCache();\n        // Initialize the tree only if there are rows inside the tree.\n        if (this.rows && this.rows.length) {\n            this.rowHeightsCache.initCache({\n                rows: this.rows,\n                rowHeight: this.rowHeight,\n                detailRowHeight: this.getDetailRowHeight,\n                externalVirtual: this.scrollbarV && this.externalPaging,\n                rowCount: this.rowCount\n            });\n        }\n    };\n    /**\n     * Gets the index for the view port\n     *\n     * @returns {number}\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.getAdjustedViewPortIndex = function () {\n        // Capture the row index of the first row that is visible on the viewport.\n        // If the scroll bar is just below the row which is highlighted then make that as the\n        // first index.\n        var viewPortFirstRowIndex = this.indexes.first;\n        if (this.scrollbarV) {\n            var offsetScroll = this.rowHeightsCache.query(viewPortFirstRowIndex - 1);\n            return offsetScroll <= this.offsetY ? viewPortFirstRowIndex - 1 : viewPortFirstRowIndex;\n        }\n        return viewPortFirstRowIndex;\n    };\n    /**\n     * Toggle the Expansion of the row i.e. if the row is expanded then it will\n     * collapse and vice versa.   Note that the expanded status is stored as\n     * a part of the row object itself as we have to preserve the expanded row\n     * status in case of sorting and filtering of the row set.\n     *\n     * @param {*} row The row for which the expansion needs to be toggled.\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.toggleRowExpansion = function (row) {\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        // If the detailRowHeight is auto --> only in case of non-virtualized scroll\n        if (this.scrollbarV) {\n            var detailRowHeight = this.getDetailRowHeight(row) * (row.$$expanded ? -1 : 1);\n            this.rowHeightsCache.update(row.$$index, detailRowHeight);\n        }\n        // Update the toggled row and update the heights in the cache.\n        row.$$expanded ^= 1;\n        this.detailToggle.emit({\n            rows: [row],\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Expand/Collapse all the rows no matter what their state is.\n     *\n     * @param {boolean} expanded When true, all rows are expanded and when false, all rows will be collapsed.\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.toggleAllRows = function (expanded) {\n        var rowExpanded = expanded ? 1 : 0;\n        // Capture the row index of the first row that is visible on the viewport.\n        var viewPortFirstRowIndex = this.getAdjustedViewPortIndex();\n        for (var _i = 0, _a = this.rows; _i < _a.length; _i++) {\n            var row = _a[_i];\n            row.$$expanded = rowExpanded;\n        }\n        if (this.scrollbarV) {\n            // Refresh the full row heights cache since every row was affected.\n            this.recalcLayout();\n        }\n        // Emit all rows that have been expanded.\n        this.detailToggle.emit({\n            rows: this.rows,\n            currentIndex: viewPortFirstRowIndex\n        });\n    };\n    /**\n     * Recalculates the table\n     *\n     * @memberOf DataTableBodyComponent\n     */\n    DataTableBodyComponent.prototype.recalcLayout = function () {\n        this.refreshRowHeightCache();\n        this.updateIndexes();\n        this.updateRows();\n    };\n    DataTableBodyComponent.decorators = [\n        { type: core_1.Component, args: [{\n                    selector: 'datatable-body',\n                    template: \"\\n    <datatable-selection\\n      #selector\\n      [selected]=\\\"selected\\\"\\n      [rows]=\\\"temp\\\"\\n      [selectCheck]=\\\"selectCheck\\\"\\n      [selectEnabled]=\\\"selectEnabled\\\"\\n      [selectionType]=\\\"selectionType\\\"\\n      [rowIdentity]=\\\"rowIdentity\\\"\\n      (select)=\\\"select.emit($event)\\\"\\n      (activate)=\\\"activate.emit($event)\\\">\\n      <datatable-progress\\n        *ngIf=\\\"loadingIndicator\\\">\\n      </datatable-progress>\\n      <datatable-scroller\\n        *ngIf=\\\"rows?.length\\\"\\n        [scrollbarV]=\\\"scrollbarV\\\"\\n        [scrollbarH]=\\\"scrollbarH\\\"\\n        [scrollHeight]=\\\"scrollHeight\\\"\\n        [scrollWidth]=\\\"columnGroupWidths.total\\\"\\n        (scroll)=\\\"onBodyScroll($event)\\\">\\n        <datatable-row-wrapper\\n          *ngFor=\\\"let row of temp; let i = index; trackBy: rowTrackingFn;\\\"\\n          [ngStyle]=\\\"getRowsStyles(row)\\\"\\n          [rowDetail]=\\\"rowDetail\\\"\\n          [detailRowHeight]=\\\"getDetailRowHeight(row,i)\\\"\\n          [row]=\\\"row\\\"\\n          [expanded]=\\\"row.$$expanded === 1\\\"\\n          (rowContextmenu)=\\\"rowContextmenu.emit($event)\\\">\\n          <datatable-body-row\\n            tabindex=\\\"-1\\\"\\n            [isSelected]=\\\"selector.getRowSelected(row)\\\"\\n            [innerWidth]=\\\"innerWidth\\\"\\n            [offsetX]=\\\"offsetX\\\"\\n            [columns]=\\\"columns\\\"\\n            [rowHeight]=\\\"getRowHeight(row)\\\"\\n            [row]=\\\"row\\\"\\n            [rowClass]=\\\"rowClass\\\"\\n            (activate)=\\\"selector.onActivate($event, i)\\\">\\n          </datatable-body-row>\\n        </datatable-row-wrapper>\\n      </datatable-scroller>\\n      <div\\n        class=\\\"empty-row\\\"\\n        *ngIf=\\\"!rows?.length\\\"\\n        [innerHTML]=\\\"emptyMessage\\\">\\n      </div>\\n    </datatable-selection>\\n  \",\n                    host: {\n                        class: 'datatable-body'\n                    }\n                },] },\n    ];\n    DataTableBodyComponent.propDecorators = {\n        'scrollbarV': [{ type: core_1.Input },],\n        'scrollbarH': [{ type: core_1.Input },],\n        'loadingIndicator': [{ type: core_1.Input },],\n        'externalPaging': [{ type: core_1.Input },],\n        'rowHeight': [{ type: core_1.Input },],\n        'offsetX': [{ type: core_1.Input },],\n        'emptyMessage': [{ type: core_1.Input },],\n        'selectionType': [{ type: core_1.Input },],\n        'selected': [{ type: core_1.Input },],\n        'rowIdentity': [{ type: core_1.Input },],\n        'rowDetail': [{ type: core_1.Input },],\n        'selectCheck': [{ type: core_1.Input },],\n        'trackByProp': [{ type: core_1.Input },],\n        'rowClass': [{ type: core_1.Input },],\n        'pageSize': [{ type: core_1.Input },],\n        'rows': [{ type: core_1.Input },],\n        'columns': [{ type: core_1.Input },],\n        'offset': [{ type: core_1.Input },],\n        'rowCount': [{ type: core_1.Input },],\n        'innerWidth': [{ type: core_1.Input },],\n        'bodyWidth': [{ type: core_1.HostBinding, args: ['style.width',] },],\n        'bodyHeight': [{ type: core_1.Input }, { type: core_1.HostBinding, args: ['style.height',] },],\n        'scroll': [{ type: core_1.Output },],\n        'page': [{ type: core_1.Output },],\n        'activate': [{ type: core_1.Output },],\n        'select': [{ type: core_1.Output },],\n        'detailToggle': [{ type: core_1.Output },],\n        'rowContextmenu': [{ type: core_1.Output },],\n        'scroller': [{ type: core_1.ViewChild, args: [scroller_component_1.ScrollerComponent,] },],\n    };\n    return DataTableBodyComponent;\n}());\nexports.DataTableBodyComponent = DataTableBodyComponent;\n",null]}