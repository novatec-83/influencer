{"remainingRequest":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@swimlane/ngx-charts/release/utils/path-tween.js","dependencies":[{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@swimlane/ngx-charts/release/utils/path-tween.js","mtime":1495471598000},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/cache-loader/dist/cjs.js","mtime":1549951013815},{"path":"/home/amjad/Downloads/influexai_Influencer_12_feb/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["import { interpolate } from 'd3-interpolate';\nexport function pathTween(d1, precision) {\n    return function () {\n        var path0 = this;\n        var path1 = path0.cloneNode();\n        var n0 = path0.getTotalLength();\n        var n1 = (path1.setAttribute('d', d1), path1).getTotalLength();\n        // Uniform sampling of distance based on specified precision.\n        var distances = [0];\n        var dt = precision / Math.max(n0, n1);\n        var i = dt;\n        while (i < 1) {\n            distances.push(i);\n            i += dt;\n        }\n        distances.push(1);\n        // Compute point-interpolators at each distance.\n        var points = distances.map(function (t) {\n            var p0 = path0.getPointAtLength(t * n0);\n            var p1 = path1.getPointAtLength(t * n1);\n            return interpolate([p0.x, p0.y], [p1.x, p1.y]);\n        });\n        return function (t) {\n            return t < 1 ? 'M' + points.map(function (p) { return p(t); }).join('L') : d1;\n        };\n    };\n}\n//# sourceMappingURL=path-tween.js.map",null]}